package uk.ac.ebi.pride.pia.modeller;

import java.io.IOException;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.bind.JAXBException;

import org.apache.log4j.Logger;

import uk.ac.ebi.pride.data.core.SearchDataBase;
import uk.ac.ebi.pride.data.core.Software;
import uk.ac.ebi.pride.data.core.SpectraData;
import uk.ac.ebi.pride.data.core.SpectrumIdentification;
import uk.ac.ebi.pride.pia.intermediate.*;
import uk.ac.ebi.pride.pia.modeller.psm.*;
import uk.ac.ebi.pride.pia.modeller.report.SortOrder;
import uk.ac.ebi.pride.pia.modeller.report.filter.AbstractFilter;
import uk.ac.ebi.pride.pia.modeller.report.filter.FilterComparator;
import uk.ac.ebi.pride.pia.modeller.report.filter.FilterFactory;
import uk.ac.ebi.pride.pia.modeller.report.filter.psm.PSMTopIdentificationFilter;
import uk.ac.ebi.pride.pia.modeller.score.FDRData;
import uk.ac.ebi.pride.pia.modeller.score.FDRScore;
import uk.ac.ebi.pride.pia.modeller.score.ScoreModel;
import uk.ac.ebi.pride.pia.modeller.score.FDRData.DecoyStrategy;
import uk.ac.ebi.pride.pia.modeller.score.ScoreModelEnum;
import uk.ac.ebi.pride.pia.modeller.score.comparator.RankCalculator;
import uk.ac.ebi.pride.pia.modeller.score.comparator.ScoreComparator;
import uk.ac.ebi.pride.pia.tools.PIAConstants;



/**
 * Modeller for the PSM related stuff.
 * 
 * @author julian
 *
 */
public class PSMModeller {
	
	/** logger for this class */
	private static final Logger logger = Logger.getLogger(PSMModeller.class);
	
	
	/** maps from the fileID to the {@link uk.ac.ebi.pride.pia.intermediate.PIAInputFile}s, they are straight from the intermediateHandler */
	private Map<Long, PIAInputFile> inputFiles;
	
	/** maps from the string ID to the {@link SearchDataBase}s, they are straight from the intermediateHandler */
	private Map<String, SearchDataBase> searchDatabases;
	
	/** maps from the string ID to the {@link uk.ac.ebi.pride.data.core.SpectraData} straight from the intermediateHandler */
	private Map<String, SpectraData> spectraData;
	
	/** maps from the string ID to the {@link uk.ac.ebi.pride.data.core.Software}s, they are straight from the intermediateHandler */
	private Map<String, Software> analysisSoftware;
	
	/** the name of the PIA XML file */
	private String fileName;
	
	/** the number of PSMs in the intermediate file*/
	private Integer nrPSMs;
	
	/** maps from the spectrum ID in the PIA intermediate file to the report PSM */
	private Map<Long, ReportPSM> spectraPSMs;
	
	/** maps from the file ID to the List of {@link uk.ac.ebi.pride.pia.modeller.psm.ReportPSM}s */
	private Map<Long, List<ReportPSM> > fileReportPSMs;
	
	/** List of the {@link ReportPSMSet}s for the whole file */
	private List<ReportPSMSet> reportPSMSets;
	
	/** map of the ReportPSMSets, for faster access in the other modellers, this is static per PIA XML file and global settings */
	private Map<String, ReportPSMSet> reportPSMSetMap;
	
	
	/** maps from the fileID to List of short names  of the scores. Actually only a reference to the same field in the {@link PIAModeller}. */
	private Map<Long, List<String>> fileScoreShortNames;
	
	/** mapping from fileId to the available sortings */
	private Map<Long, Set<String>> fileSortables;
	
	/** maps from the fileID to the corresponding FDR data */
	private Map<Long, FDRData> fileFDRData;
	
	/** maps from the fileID to whether an FDR is calculated or not */
	private Map<Long, Boolean> fileFDRCalculated;
	
	/** map from the file's id to the used top identifications for FDR calculation */
	private Map<Long, Integer> fileTopIdentifications;
	
	/** Maps, whether the file has PSMs with decoy information from the searchengine or otherwise in the PIA XML defined decoys or not */
	private Map<Long, Boolean> fileHasInternalDecoy;
	
	/** The warnings generated by the {@link} for the PSMSetSettings */
	private Map<String, Set<Long>> psmSetSettingsWarnings;
	
	/** The represented {@link IdentificationKeySettings} in this Set are used for the calculation of PSM sets or not */
	private Map<String, Boolean> psmSetSettings;
	
	/** whether to create PSM sets at all or use every PSM independently (useful for data sets with several runs and one search engine) */
	private boolean createPSMSets;
	
	/** a list of score shortnames, representing the preferred score for the FDR calulation (if it is not manually set) */
	private List<String> preferredFDRScores;
	
	/** maps from the scoreShort to the scoreName */
	private Map<String, String> scoreShortToScoreName;
	
	/** maps from the scoreShort to the comparator */
	private Map<String, Comparator<PSMReportItem>> scoreShortToComparator;
	
	/** maps from the score short to whether the higher score is better (probably current setting) */
	private Map<String, Boolean> scoreShortToHigherScoreBetter;
	
	/** maps from the score short to whether the higher score better is changeable, because it was not hard coded or found in a CV */
	private Map<String, Boolean> scoreShortToHigherScoreBetterChangeable;
	
	
	/** default decoy pattern */
	private String defaultDecoyPattern;
	
	/** default FDR threshold */
	private Double defaultFDRThreshold;
	
	/** default for the number of highest ranking PSMs (per spectrum) used for FDR calculation */
	private Integer defaultFDRTopIdentifications;
	
	
	/** the list of filters applied to the data, mapped by the file ID */
	private Map<Long, List<AbstractFilter>> fileFiltersMap;
	
	
	/** the PSMSetSettings for the SpectrumIdentificationResults in mzIdentML export */
	private Map<String, Boolean> resultPSMSetSettings;
	
	/** the PSMSetSettings for the SpectrumIdentificationItems in mzIdentML export */
	private Map<String, Boolean> itemPSMSetSettings;
	
	
	/**
	 * Basic constructor, creates the {@link ReportPSM}s and
	 * {@link ReportPSMSet}s from the given {@link uk.ac.ebi.pride.pia.intermediate.IntermediateGroup}s. The {@link IntermediateGroup}s
	 * should derive from a {@link PIAInputFile}.
	 * 
	 * @param groups groups of the PIA intermediate file
	 * @param inputFiles the used {@link PIAInputFile}s
	 * @param fileName map, which will be filled with the scoreNames for each file
	 */
	public PSMModeller(Map<Long, IntermediateGroup> groups,
			Map<Long, PIAInputFile> inputFiles,
			Map<String, SearchDataBase> searchDatabases,
			Map<String, SpectraData> spectraData,
			Map<String, Software> software,
			String fileName,
			Map<String, Set<Long>> psmSetSettingsWarnings,
			Integer nrPSMs) {
		
		// create the file mapping and also add the overview file with ID 0
		this.inputFiles = new HashMap<Long, PIAInputFile>(inputFiles.size()+1);
		this.inputFiles.put(0L, new PIAInputFile(0L, "All files",
				"Overview_of_all_files", "none"));
		this.inputFiles.putAll(inputFiles);
		
		fileFiltersMap = new HashMap<Long, List<AbstractFilter>>(inputFiles.size());
		
		this.searchDatabases = searchDatabases;
		this.spectraData = spectraData;
		this.analysisSoftware = software;
		this.fileName = fileName;
		
		this.scoreShortToScoreName = new HashMap<String, String>();
		
		// TODO: get defaults from ini-file (or something like that)
		defaultDecoyPattern = "s.*";
		defaultFDRThreshold = 0.01;
		defaultFDRTopIdentifications = 0;
		preferredFDRScores = new ArrayList<String>();
		
		// initialize the used PSM set settings
		this.psmSetSettingsWarnings = psmSetSettingsWarnings;
		this.psmSetSettings = new HashMap<String, Boolean>(IdentificationKeySettings.values().length);
		for (IdentificationKeySettings setting : IdentificationKeySettings.values()) {
			if ((psmSetSettingsWarnings.get(setting.toString()) != null) &&
					(psmSetSettingsWarnings.get(setting.toString()).size() > 0)) {
				this.psmSetSettings.put(setting.toString(), false);
			} else {
				this.psmSetSettings.put(setting.toString(), true);
			}
		}
		
		// remove redundant psmSetSettings (and use only the more failure tolerant ones)
		psmSetSettings =
				IdentificationKeySettings.noRedundantSettings(psmSetSettings);
		
		this.createPSMSets = true;
		if (this.createPSMSets) {
			this.psmSetSettings.remove(
					IdentificationKeySettings.FILE_ID.toString());
		}
		
		// no settings are needed for the calculation of the ReportPSMs, but the PSM Set settings are used
		this.nrPSMs = nrPSMs;

	}
	
	
	/**
	 * Applies the general settings and recalculates the PSMSets
	 */
	public void applyGeneralSettings(boolean createPSMSets,
			Map<String, Boolean> psmSetSettings) {
		// only do something, if it is needed
		if ((this.createPSMSets != createPSMSets) ||
				!this.psmSetSettings.equals(psmSetSettings)) {
			this.createPSMSets = createPSMSets;
			this.psmSetSettings = psmSetSettings;
			
			if (!this.createPSMSets) {
				// no sets across files needed -> put fileID into settings
				this.psmSetSettings.put(IdentificationKeySettings.FILE_ID.name(),
						true);
			}
			
			// rebuild the PSM sets
			List<AbstractFilter> filters = getFilters(0L);
			
			// map to create the PSMSets
			Map<String, List<ReportPSM>> psmSetsMap =
					new HashMap<String, List<ReportPSM>>();
			
			// sort the PSMs in sets with their identificationKeys
			for (ReportPSM psm : spectraPSMs.values()) {
				if (FilterFactory.satisfiesFilterList(psm, 0L, filters)) {
					String psmKey = psm.getIdentificationKey(this.psmSetSettings);
					
					// put the PSM in the psmKey -> ReportPSM map
					if (!psmSetsMap.containsKey(psmKey)) {
						psmSetsMap.put(psmKey, new ArrayList<ReportPSM>());
					}
					psmSetsMap.get(psmKey).add(psm);
				}
			}
			
			createReportPSMSets(psmSetsMap);
		}
	}
	
	
	/**
	 * Gets whether PSM sets should be used across files
	 * @return
	 */
	public Boolean getCreatePSMSets() {
		return createPSMSets;
	}
	
	
	/**
	 * Sets whether PSM sets should be used across files
	 * @param createPSMSets
	 */
	public void setCreatePSMSets(Boolean createPSMSets) {
		this.createPSMSets = createPSMSets;
	}
	
	
	/**
	 * Getter for the {@link IdentificationKeySettings}.
	 * @return
	 */
	public Map<String, Boolean> getPSMSetSettings() {
		return psmSetSettings;
	}
	
	
	/**
	 * Getter for the PSMSetSettingsWarnings
	 * @return
	 */
	public Map<String, Set<Long>> getPSMSetSettingsWarnings() {
		return psmSetSettingsWarnings;
	}
	
	

	
	/**
	 * Creates the {@link ReportPSMSet}s, given the {@link ReportPSM}s in a
	 * mapping from the PSM-identificationKeys
	 * @param psmSetsMap
	 */
	private void createReportPSMSets(Map<String, List<ReportPSM>> psmSetsMap) {
		reportPSMSetMap = new HashMap<String, ReportPSMSet>(psmSetsMap.size());
		
		for (Map.Entry<String, List<ReportPSM>> psmSetsIt : psmSetsMap.entrySet()) {
			ReportPSMSet psmSet =
					new ReportPSMSet(psmSetsIt.getValue(), psmSetSettings);
			reportPSMSetMap.put(psmSetsIt.getKey(), psmSet);
		}
		
		reportPSMSets = new ArrayList<ReportPSMSet>(
				reportPSMSetMap.values());
		
		fileFDRData.put(0L,
				new FDRData(fileFDRData.get(0L).getDecoyStrategy(),
						fileFDRData.get(0L).getDecoyPattern(),
						fileFDRData.get(0L).getFDRThreshold()));
	}
	
	
	/**
	 * Returns a key by which the PSMs can be grouped for calculation of top
	 * rank identifications.
	 * 
	 * @param psm
	 * @return
	 */
	private String createPSMKeyForScoreRanking(ReportPSM psm) {
		return psm.getSourceID() + ":" + psm.getSpectrum().getSpectrumTitle() +
				":" + psm.getMassToCharge() + ":" + psm.getSpectrum().getRetentionTime();
	}
	
	
	/**
	 * Getter for the files used in the PIA intermediate file, including the
	 * pseudo-overview-file.
	 * 
	 * @return
	 */
	public Map<Long, PIAInputFile> getFiles() {
		return inputFiles;
	}
	
	
	/**
	 * Getter for the filename of the PIA XML file.
	 * 
	 * @return
	 */
	public String getFileName() {
		return fileName;
	}
	
	
	/**
	 * Getter for the default decoy pattern.
	 * @return
	 */
	public String getDefaultDecoyPattern() {
		return defaultDecoyPattern;
	}
	
	
	/**
	 * Getter for the default FDR threshold for acceptance.
	 * @return
	 */
	public Double getDefaultFDRThreshold() {
		return defaultFDRThreshold;
	}
	
	
	/**
	 * Getter for the default number of highest ranking PSMs (per spectrum) used
	 * for FDR calculation.
	 * @return
	 */
	public Integer getDefaultFDRTopIdentifications() {
		return defaultFDRTopIdentifications;
	}
	
	
	/**
	 * Reports the mapping from the ReportPSMSet identificationKeys to the
	 * {@link ReportPSMSet}s. This map includes all possible, unfiltered PSM
	 * sets.
	 * 
	 * @return
	 */
	public Map<String, ReportPSMSet> getReportPSMSets() {
		return reportPSMSetMap;
	}
	
	
	/**
	 * Returns the number of PSMs or PSM sets for the given file ID. 
	 * @param fileID
	 * @return
	 */
	public int getNrReportPSMs(Long fileID) {
		if (fileID > 0) {
			if (fileReportPSMs.containsKey(fileID)) {
				return fileReportPSMs.get(fileID).size();
			} else {
				return -1;
			}
		} else {
			return reportPSMSets.size();
		}
	}
	
	
	/**
	 * Returns the filtered List of {@link ReportPSM}s for the given fileID.
	 * 
	 * @param fileID
	 * @param filters
	 * @return
	 */
	public List<ReportPSM> getFilteredReportPSMs(Long fileID,
			List<AbstractFilter> filters) {
		if (fileReportPSMs.containsKey(fileID)) {
			return FilterFactory.applyFilters(fileReportPSMs.get(fileID),
                    filters, fileID);
		} else {
			logger.error("There are no ReportPSMs for the fileID " + fileID);
			return new ArrayList<ReportPSM>(1);
		}
	}
	
	
	/**
	 * Returns the filtered List of {@link ReportPSMSet}s for the PSM sets,
	 * applying the given filters.
	 * 
	 * @param filters
	 * @return
	 */
	public List<ReportPSMSet> getFilteredReportPSMSets(
			List<AbstractFilter> filters) {
		List<ReportPSMSet> filteredPSMSets = new ArrayList<ReportPSMSet>();
		
		// the PSM sets need a special filtering, some of the sets can become empty, due to filters on PSM level
		for (ReportPSMSet psmSet : reportPSMSets) {
			if (FilterFactory.satisfiesFilterList(psmSet, 0L, filters)) {
				List<ReportPSM> psms = FilterFactory.applyFilters(
						psmSet.getPSMs(), filters);
				
				if (psms.size() > 0) {
					ReportPSMSet set = new ReportPSMSet(psms, psmSetSettings);
					set.copyInfo(psmSet);
					filteredPSMSets.add(set);
				}
			}
		}
		
		return filteredPSMSets;
	}
	

	public String getScoreName(String shortName) {
		return scoreShortToScoreName.get(shortName);
	}
	

	public Boolean getHigherScoreBetterChangeable(String scoreShort) {
		return scoreShortToHigherScoreBetterChangeable.get(scoreShort);
	}
	
	
	/**
	 * Gets whether the higherScoreBetter is true or false for the score.
	 * 
	 * @param scoreShort
	 * @return
	 */
	public Boolean getHigherScoreBetter(String scoreShort) {
		return scoreShortToHigherScoreBetter.get(scoreShort);
	}
	
	
	/**
	 * Sets whether the higherScoreBetter is true or false for the score.
	 * 
	 * @param scoreShort
	 */
	public void setHigherScoreBetter(String scoreShort,
			Boolean higherScoreBetter) {
		if (scoreShortToHigherScoreBetterChangeable.get(scoreShort)) {
			scoreShortToHigherScoreBetter.put(scoreShort, higherScoreBetter);
			
			scoreShortToComparator.put(scoreShort,
					new ScoreComparator<PSMReportItem>(
							scoreShort, higherScoreBetter));
			
			logger.debug("setHigherScoreBetter: " + scoreShortToComparator.get(scoreShort));
		} else {
			logger.warn("The comparator for " + scoreShort + "(" +
					scoreShortToScoreName.get(scoreShort) +
					") may not be changed!");
		}
	}
	
	
	/**
	 * Returns the comparator for the given short.
	 * 
	 * @param scoreShort
	 * @return
	 */
	public Comparator<PSMReportItem> getScoreComparator(String scoreShort) {
		if (scoreShortToComparator.containsKey(scoreShort)) {
			return scoreShortToComparator.get(scoreShort);
		}
		
		logger.warn("no comparator found for " + scoreShort);
		return null;
	}
	
	
	/**
	 * Returns for the given score, whether a higher score is better.
	 * 
	 * @param scoreShort
	 * @return
	 */
	public Boolean getHigherScoreBetterForScore(String scoreShort) {
		return scoreShortToHigherScoreBetter.get(scoreShort);
	}
	
	
	/**
	 * Getter for the shortNames of all scores of the given file
	 * 
	 * @param fileID
	 * @return
	 */
	public List<String> getScoreShortNames(Long fileID) {
		if (fileScoreShortNames.containsKey(fileID)) {
			return fileScoreShortNames.get(fileID);
		} else {
			return new ArrayList<String>(1);
		}
	}
	
	
	/**
	 * Returns the mapping from the shortNames to the nicely readable names.
	 * 
	 * @return
	 */
	public Map<String, String> getScoreShortsToScoreNames() {
		return scoreShortToScoreName;
	}
	
	
	/**
	 * Returns the {@link FDRData} for the file with the given ID.
	 * 
	 * @param fileID
	 * @return
	 */
	public FDRData getFilesFDRData(Long fileID) {
		return fileFDRData.get(fileID);
	}
	
	
	/**
	 * Getter for the map of FDR data
	 * @return
	 */
	public Map<Long, FDRData> getFileFDRData() {
		return fileFDRData;
	}
	
	
	/**
	 * Returns the set number of top identifications used for the FDR
	 * calculation for the given file.
	 * 
	 * @param fileID
	 * @return
	 */
	public Integer getFilesTopIdentifications(Long fileID) {
		return fileTopIdentifications.get(fileID);
	}
	
	
	/**
	 * Sets the number of top identifications used for the FDR calculation for
	 * the given file.
	 * 
	 * @param fileID
	 * @return
	 */
	public void setFilesTopIdentifications(Long fileID, Integer topIDs) {
		fileTopIdentifications.put(fileID, topIDs);
	}
	
	
	/**
	 * Sets the number of top identifications used for the FDR calculation for
	 * all files.
	 *
	 * @return
	 */
	public void setAllTopIdentifications(Integer topIDs) {
		for (Long fileID : fileTopIdentifications.keySet()) {
			setFilesTopIdentifications(fileID, topIDs);
		}
	}
	
	
	/**
	 * Sets the given pattern as the decoy pattern for all files' FDR data and
	 * sets the FDR decoy strategy to
	 * {@link FDRData.DecoyStrategy}.ACCESSIONPATTERN, unless "searchengine" is
	 * given as pattern, which will set
	 * {@link FDRData.DecoyStrategy}.SEARCHENGINE as decoy strategy.
	 * 
	 * @param pattern
	 */
	public void setAllDecoyPattern(String pattern) {
		FDRData.DecoyStrategy decoyStrategy;
		boolean setPattern;
		
		if (FDRData.DecoyStrategy.SEARCHENGINE.toString().equals(pattern)) {
			decoyStrategy = FDRData.DecoyStrategy.SEARCHENGINE;
			setPattern = false;
		} else {
			decoyStrategy = FDRData.DecoyStrategy.ACCESSIONPATTERN;
			setPattern = true;
		}
		
		for (FDRData fdrData : fileFDRData.values()) {
			fdrData.setDecoyStrategy(decoyStrategy);
			if (setPattern) {
				fdrData.setDecoyPattern(pattern);
			}
		}
	}
	
	
	/**
	 * Updates the {@link FDRData} for the given file.
	 * 
	 * @param fileID
	 * @return
	 */
	public void updateFilesFDRData(Long fileID, DecoyStrategy decoyStrategy,
			String decoyPattern, Double fdrThreshold, String scoreModelShort,
			Integer topIdentifications) {
		FDRData fdrData = fileFDRData.get(fileID);
		
		if (fdrData != null) {
			fdrData.setDecoyStrategy(decoyStrategy);
			fdrData.setDecoyPattern(decoyPattern);
			fdrData.setFDRThreshold(fdrThreshold);
			fdrData.setScoreShortName(scoreModelShort);
			
			setFilesTopIdentifications(fileID, topIdentifications);
			
			logger.info(fileID + "'s FDRData set to: " +
					fdrData.getDecoyStrategy() + ", " +
					fdrData.getDecoyPattern() + ", " +
					fdrData.getFDRThreshold() + ", " +
					fdrData.getScoreShortName() + ", " +
					getFilesTopIdentifications(fileID));
		} else {
			logger.error("No FDRData for file with ID " + fileID);
		}
	}
	
	
	/**
	 * Returns a List of scoreShortNames of available Scores for FDR calculation
	 * for the given file.
	 * 
	 * @param fileID
	 * @return
	 */
	public List<String> getFilesAvailableScoreShortsForFDR(Long fileID) {
		List<String> fdrScoreNames = new ArrayList<String>();
		
		// the overview is treated separately (it has no available scores, but only the FDRScore
		if (fileID > 0) {
			if (fileScoreShortNames.containsKey(fileID)) {
				List<String> scoreShorts = fileScoreShortNames.get(fileID);
				for (int i=0; i < scoreShorts.size(); i++) {
					if (!ScoreModelEnum.PSM_LEVEL_FDR_SCORE.isValidDescriptor(scoreShorts.get(i))) {
						// FDR score is not available for FDR calculation
						fdrScoreNames.add(scoreShorts.get(i));
					}
				}
			} else {
				logger.error("No scores available for FDR calculation for the file with ID "+fileID);
			}
		}
		
		return fdrScoreNames;
	}
	
	
	/**
	 * Returns a mapping from the file IDs to the scoreNames used for FDR
	 * calculation for each file.
	 * 
	 * @return
	 */
	public Map<Long, String> getFileIDsToScoreOfFDRCalculation() {
		Map<Long, String> filenameToScoreOfFDRCalculation = new HashMap<Long, String>(inputFiles.size()-1);
		
		for (PIAInputFile file : inputFiles.values()) {
			if (file.getID() != 0L) {
				String scoreName;
				Boolean fdrCalculated = fileFDRCalculated.get(file.getID());
				if (fdrCalculated) {
					FDRData fdrData = fileFDRData.get(file.getID());
					scoreName = ScoreModelEnum.getName(fdrData.getScoreShortName());
				} else {
					scoreName = "no FDR calculated";
				}
				
				filenameToScoreOfFDRCalculation.put(file.getID(), scoreName);
			}
		}
		
		return filenameToScoreOfFDRCalculation;
	}
	
	
	/**
	 * Returns, whether for the given file an FDR is calculated.
	 * @param fileID
	 * @return
	 */
	public Boolean isFDRCalculated(Long fileID) {
		return fileFDRCalculated.get(fileID);
	}
	
	
	/**
	 * Returns true, if all files have a calculated FDR.
	 * @return
	 */
	public Boolean getAllFilesHaveFDRCalculated() {
		for (PIAInputFile file : inputFiles.values()) {
			if ((file.getID() > 0) &&
					((fileFDRCalculated.get(file.getID()) == null) ||
					!fileFDRCalculated.get(file.getID()))) {
				return false;
			}
			
		}
		
		return true;
	}
	
	
	/**
	 * Returns whether the combined FDR Score is calculated. 
	 * @return
	 */
	public boolean isCombinedFDRScoreCalculated() {
		return ((reportPSMSets.size() > 0) &&
				(fileFDRCalculated.get(0L) != null) &&
				fileFDRCalculated.get(0L));
	}
	
	
	/**
	 * Returns, whether the file with the given ID has internal decoys, i.e.
	 * PSMs which are set to be decoys in the PIA XML file.
	 * 
	 * @param fileID
	 * @return
	 */
	public Boolean getFileHasInternalDecoy(Long fileID) {
		return fileHasInternalDecoy.get(fileID);
	}
	
	
	/**
	 * Updates the decoy states of the PSMs with the current settings from the
	 * file's FDRData.
	 * 
	 */
	public void updateDecoyStates(Long fileID) {
		FDRData fdrData = fileFDRData.get(fileID);
		
		logger.info("updateDecoyStates " + fileID);
		
		// select either the PSMs from the given file or all and calculate the fdr
		if (fdrData == null) {
			logger.error("No FDR settings given for file with ID=" + fileID);
			// TODO: throw an exception or something
			return;
		} else {
			Pattern p = Pattern.compile(fdrData.getDecoyPattern());
			
			if (fileID > 0) {
				// get a List of the ReportPSMs for FDR calculation
				List<ReportPSM> listForFDR = fileReportPSMs.get(fileID);
				
				if (listForFDR == null) {
					logger.error("No PSMs found for the file with ID=" + fileID);
					// TODO: throw an exception
					return;
				}
				
				for (ReportPSM psm : listForFDR) {
					// dump all FDR data
					psm.dumpFDRCalculation();
					psm.updateDecoyStatus(fdrData.getDecoyStrategy(), p);
				}
			} else {
				// set decoy information for PSM sets
				for (ReportPSMSet psmSet : reportPSMSets) {
					psmSet.dumpFDRCalculation();
					psmSet.updateDecoyStatus(fdrData.getDecoyStrategy(), p);
				}
			}
		}
	}
	
	
	/**
	 * Calculate the FDR for all files. <br/>
	 * If no score for the FDR calculation is given, use a default.
	 */
	public void calculateAllFDR() {
		for (Long fileID : fileReportPSMs.keySet()) {
			calculateFDR(fileID);
		}
	}
	
	
	/**
	 * Calculate the FDR for the file given by fileID
	 * 
	 * @param fileID
	 */
	public void calculateFDR(Long fileID) {
		FDRData fdrData = fileFDRData.get(fileID);
		
		// select either the PSMs from the given file or all and calculate the fdr
		if (fdrData == null) {
			logger.error("No FDR settings given for file with ID=" + fileID);
			// TODO: throw an exception
			return;
		} else {
			// if no score for FDR score is given, set either a preferred or the
			// first available from the set
			if (fdrData.getScoreShortName() == null) {
				// first look in the preferred scores
				for (String scoreShort : preferredFDRScores) {
					if (fileScoreShortNames.get(fileID).contains(scoreShort)) {
						fdrData.setScoreShortName(scoreShort);
						break;
					}
				}
				
				// if no score is set yet, take the first best score
				if (fdrData.getScoreShortName() == null) {
					fdrData.setScoreShortName(
							fileScoreShortNames.get(fileID).get(0));
				}
				
				logger.info("set the score for FDR calculation for fileID=" +
						fileID + ": " + fdrData.getScoreShortName());
			}
			
			// recalculate the decoy status (especially important, if decoy pattern was changed)
			updateDecoyStates(fileID);
			
			
			if (fileReportPSMs.get(fileID) == null) {
				logger.error("No PSMs found for the file with ID=" + fileID);
				// TODO: throw an exception
				return;
			}
			
			// get a List of the ReportPSMs for FDR calculation
			List<PSMReportItem> listForFDR = new ArrayList<PSMReportItem>(fileReportPSMs.get(fileID));
			
			if ((fileTopIdentifications.get(fileID) != null) &&
					(fileTopIdentifications.get(fileID) > 0)) {
				
				logger.info("applying topIdentification filter: top " +
						fileTopIdentifications.get(fileID) + " for " +
						fdrData.getScoreShortName());
				
				for (PSMReportItem psm : listForFDR) {
					// as the used ReportPSMs may change with the filter, clear all prior FDR information
					psm.dumpFDRCalculation();
				}
				
				// only the topIdentifications should be used, so a filter is needed
				List<AbstractFilter> topRankFilter = new ArrayList<AbstractFilter>(1);
				
				topRankFilter.add(new PSMTopIdentificationFilter(
						FilterComparator.less_equal,
						fileTopIdentifications.get(fileID),
						false,
						fdrData.getScoreShortName()));
				
				List<PSMReportItem> filteredList = FilterFactory.applyFilters(
						listForFDR,
						topRankFilter,
						fileID);
				
				listForFDR = filteredList;
			}
			
			
			if (scoreShortToComparator.get(fdrData.getScoreShortName()) == null) {
				logger.warn("No comparator for FDR calculation, "
						+ "aborted calculateFDR!");
				return;
			}
			
			// calculate the FDR values
			fdrData.calculateFDR(listForFDR,
					scoreShortToComparator.get(fdrData.getScoreShortName()));
			
			// and also calculate the FDR score
			FDRScore.calculateFDRScore(listForFDR, fdrData,
					scoreShortToHigherScoreBetter.get(fdrData.getScoreShortName()));
			
			
			List<String> scoreShorts = fileScoreShortNames.get(fileID);
			if (!scoreShorts.contains(ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getShortName())) {
				// add the FDR score to scores of this file
				scoreShorts.add(ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getShortName());
				scoreShortToScoreName.put(
						ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getShortName(),
						ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getName());
				scoreShortToComparator.put(ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getShortName(),
						new ScoreComparator<PSMReportItem>(
								ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getShortName(),
								false));
				scoreShortToHigherScoreBetter.put(
						ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getShortName(),
						false);
				scoreShortToHigherScoreBetterChangeable.put(
						ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getShortName(),
						false);
				
				// and also to the sortable fields
				fileSortables.get(fileID).add(
						PSMReportItemComparator.getScoreSortName(ScoreModelEnum.PSM_LEVEL_FDR_SCORE.getShortName()) );
			}
			
			// the FDR for this file is calculated now
			fileFDRCalculated.put(fileID, true);
		}
	}
	
	
	/**
	 * Clears all preferred FDR scores.
	 */
	public void resetPreferredFDRScores() {
		preferredFDRScores.clear();
		
		// set all FDR data scoreshorts for the regular files to null
		for (Map.Entry<Long, FDRData> fdrIt : fileFDRData.entrySet()) {
			if (!fdrIt.getKey().equals(0L)) {
				fdrIt.getValue().setScoreShortName(null);
			}
		}
	}
	
	
	/**
	 * Adds the given scoreShortNames to the preferred FDR scores.
	 */
	public void addPreferredFDRScores(List<String> scoreShortNames) {
		for (String scoreShortName : scoreShortNames) {
			addPreferredFDRScore(scoreShortName);
		}
	}
	
	
	/**
	 * Adds the score with the given short to the preferred FDR scores. If the
	 * score does not exist, do nothing.
	 * 
	 * @param scoreShortName
	 */
	public void addPreferredFDRScore(String scoreShortName) {
		if (scoreShortName == null) {
			return;
		}
		
		// get the unique score shortName, if the score is known
		ScoreModelEnum model =
				ScoreModelEnum.getModelByDescription(scoreShortName);
		String shortName = model.getShortName();
		if (shortName == null) {
			// for an unknown score, take the given shortName
			shortName = scoreShortName;
		}
		
		if (!preferredFDRScores.contains(shortName)) {
			preferredFDRScores.add(shortName);
		}
	}
	
	
	/**
	 * Calculates the Combined FDR Score for the PSM sets in the overview 
	 */
	public void calculateCombinedFDRScore() {
		Map<String, List<ReportPSMSet>> fileLists = new HashMap<String, List<ReportPSMSet>>();
		String key;
		
		updateDecoyStates(0L);
		
		// first we need the Average FDR Score for each PSM set
		for (ReportPSMSet set : reportPSMSets) {
			set.calculateAverageFDRScore();
			
			if (!set.getAverageFDRScore().getValue().equals(Double.NaN)) {
				// put the PSM set into the List, which holds the sets identified in the same files
				if (set.getPSMs().size() > 1) {
					
					Set<Long> files = new TreeSet<Long>();
					for (ReportPSM psm : set.getPSMs()) {
						if ((psm.getFDRScore() != null) &&
								!psm.getFDRScore().getValue().equals(Double.NaN)) {
							// the psm has a valid FDR for this file
							files.add(psm.getFileID());
						}
					}
					
					StringBuffer sbKey = new StringBuffer("");
					
					for (Long file : files) {
						if (sbKey.length() > 0) {
							sbKey.append(":");
						}
						sbKey.append(file);
					}
					key = sbKey.toString();
				} else {
					key = set.getPSMs().get(0).getFileID().toString();
				}
				
				if (!fileLists.containsKey(key)) {
					fileLists.put(key, new ArrayList<ReportPSMSet>());
				}
				
				fileLists.get(key).add(set);
			} else {
				// this PSM set gets no Combined FDR Score
				set.setFDRScore(Double.NaN);
			}
		}
		
		
		// go through the search-engine-sets, sort by AFS and calculate combined FDR Score
		for (Map.Entry<String, List<ReportPSMSet>> seSetIt : fileLists.entrySet()) {
			logger.info("Calculation of Combined FDR Score for " + seSetIt.getKey());
			
			Collections.sort(seSetIt.getValue(),
					new ScoreComparator<ReportPSMSet>(ScoreModelEnum.AVERAGE_FDR_SCORE.getShortName()));
			
			FDRData fdrData = fileFDRData.get(0L);
			
			fdrData.setScoreShortName(ScoreModelEnum.AVERAGE_FDR_SCORE.getShortName());
			fdrData.calculateFDR(seSetIt.getValue());
			
			if (seSetIt.getValue().size() > 2) {
				FDRScore.calculateFDRScore(seSetIt.getValue(), fdrData,
						ScoreModelEnum.AVERAGE_FDR_SCORE.higherScoreBetter());
			} else {
				for (ReportPSMSet set : seSetIt.getValue()) {
					set.setFDRScore(set.getAverageFDRScore().getValue());
				}
			}
		}
		
		
		// add to the sortable fields
		fileSortables.get(0L).add(
				PSMReportItemComparator.getScoreSortName(ScoreModelEnum.PSM_LEVEL_COMBINED_FDR_SCORE.getShortName()) );
		
		// and add to the score fields
		fileScoreShortNames.put(0L, new ArrayList<String>(1));
		fileScoreShortNames.get(0L).add(ScoreModelEnum.PSM_LEVEL_COMBINED_FDR_SCORE.getShortName());
		scoreShortToScoreName.put(
				ScoreModelEnum.PSM_LEVEL_COMBINED_FDR_SCORE.getShortName(),
				ScoreModelEnum.PSM_LEVEL_COMBINED_FDR_SCORE.getName());
		scoreShortToComparator.put(ScoreModelEnum.PSM_LEVEL_COMBINED_FDR_SCORE.getShortName(),
				new ScoreComparator<PSMReportItem>(
						ScoreModelEnum.PSM_LEVEL_COMBINED_FDR_SCORE.getShortName(),
						false));
		scoreShortToHigherScoreBetter.put(
				ScoreModelEnum.PSM_LEVEL_COMBINED_FDR_SCORE.getShortName(),
				false);
		scoreShortToHigherScoreBetterChangeable.put(
				ScoreModelEnum.PSM_LEVEL_COMBINED_FDR_SCORE.getShortName(),
				false);
		
		// correct the numbers of decoys etc.
		int nrDecoys = 0;
		int nrTargets = 0;
		int nrItems = 0;
		int nrFDRGoodDecoys = 0;
		int nrFDRGoodTargets = 0;
		double thr = fileFDRData.get(0L).getFDRThreshold();
		
		for (ReportPSMSet set : reportPSMSets) {
			/*
			if (set.getFDRScore() == null) {
				logger.warn("FDRScore == null " + set.getSequence() + " " + set.getSourceID());
				set.setFDRScore(Double.NaN);
			}
			*/
			
			if (!set.getFDRScore().getValue().equals(Double.NaN)) {
				nrItems++;
				if (set.getIsDecoy()) {
					nrDecoys++;
					if (set.getFDRScore().getValue() <= thr) {
						nrFDRGoodDecoys++;
					}
				} else {
					nrTargets++;
					if (set.getFDRScore().getValue() <= thr) {
						nrFDRGoodTargets++;
					}
				}
			}
		}
		
		fileFDRData.get(0L).correctNumbers(nrDecoys, nrFDRGoodDecoys,
				nrFDRGoodTargets, nrItems, nrTargets);
		
		// the combined FDR is calculated now
		fileFDRCalculated.put(0L, true);
	}
    
	/**
	 * Returns a List of scoreShortNames of available Scores for ranking.
	 * 
	 * @param fileID
	 * @return
	 */
	public List<String> getFilesAvailableScoreShortsForRanking(Long fileID) {
		List<String> rankingScoreNames = new ArrayList<String>();
		
		if (fileScoreShortNames.containsKey(fileID)) {
			for (String scoreShort : fileScoreShortNames.get(fileID)) {
				rankingScoreNames.add(scoreShort);
			}
		}
		
		if ((rankingScoreNames.size() < 1) && (fileID > 0)) {
			logger.error("No scores available for ranking for the file with ID "+fileID);
		}
		
		return rankingScoreNames;
	}
    
	
	/**
	 * Calculates the ranking for the given file and scoreShortName. If the
	 * filter List is not null or empty, the Report is filtered before ranking.
	 */
	public void calculateRanking(Long fileID, String rankableShortName,
			List<AbstractFilter> filters) {
		if ((rankableShortName == null) || rankableShortName.trim().equals("")) {
			logger.error("No score shortName given for ranking calculation.");
			return;
		}
		
		// first, dump all prior ranking
		List<?> reports;
		if (fileID > 0) {
			reports = fileReportPSMs.get(fileID);
		} else {
			reports = reportPSMSets;
		}
		if (reports != null) {
			for (Object obj : reports) {
				if (obj instanceof PSMReportItem) {
					((PSMReportItem) obj).setRank(-1L);
				}
			}
		}
		
		if (fileID > 0) {
			RankCalculator.calculateRanking(rankableShortName,
					FilterFactory.applyFilters(fileReportPSMs.get(fileID),
							filters, fileID),
					new ScoreComparator<ReportPSM>(rankableShortName));
		} else {
			RankCalculator.calculateRanking(rankableShortName,
					FilterFactory.applyFilters(reportPSMSets,
							filters, fileID),
					new ScoreComparator<ReportPSMSet>(rankableShortName));
		}
	}
	
	
	/**
	 * Returns the filters set for the given file.
	 * @param fileID
	 * @return
	 */
	public List<AbstractFilter> getFilters(Long fileID) {
		List<AbstractFilter> filters = fileFiltersMap.get(fileID);
		if (filters == null) {
			filters = new ArrayList<AbstractFilter>();
			fileFiltersMap.put(fileID, filters);
		}
		
		return filters;
	}
	
	
	/**
	 * Add a new filter for the given file
	 */
	public boolean addFilter(Long fileID, AbstractFilter newFilter) {
		if (newFilter != null) {
			return getFilters(fileID).add(newFilter);
		} else {
			return false;
		}
	}
	


	
	/**
	 * Processes the command line on the PSM level
	 * @param model
	 * @param commands
	 * @return
	 */
	public static boolean processCLI(PSMModeller model, String[] commands) {
		if (model == null) {
			logger.error("No PSM modeller given while processing CLI commands");
			return false;
		}
		
		Pattern pattern = Pattern.compile("^([^=]+)=(.*)");
		Matcher commandParamMatcher;
		
		for (String command : commands) {
			String[] params = null;
			commandParamMatcher = pattern.matcher(command);
			
			if (commandParamMatcher.matches()) {
				command = commandParamMatcher.group(1);
				params = commandParamMatcher.group(2).split(",");
			}
			
			try {
				//PSMExecuteCommands.valueOf(command).execute(model, params);
			} catch (IllegalArgumentException e) {
				logger.error("Could not process unknown call to " +
						command);
			}
		}
		
		return true;
	}
}
