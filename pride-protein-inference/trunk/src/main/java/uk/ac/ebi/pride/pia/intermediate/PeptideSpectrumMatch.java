package uk.ac.ebi.pride.pia.intermediate;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import uk.ac.ebi.pride.data.core.ParamGroup;
import uk.ac.ebi.pride.data.core.SpectrumIdentification;

import uk.ac.ebi.pride.pia.modeller.IdentificationKeySettings;
import uk.ac.ebi.pride.pia.modeller.score.ScoreModel;
import uk.ac.ebi.pride.pia.modeller.score.ScoreModelEnum;
import uk.ac.ebi.pride.pia.tools.PIATools;


/**
 * This class represents a peptide spectrum match (PSM).
 * 
 * @author julian
 * 
 */
public class PeptideSpectrumMatch implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	/** internal ID of the PSM */
	private long ID;
	
	/** the original ID of the spectrum in the file (as in mzIdentML) */
	private String sourceID;

	/** pointer to the file, where this PSM comes from */
	private String spectraDataId;

	/** whether this PSM is unique (in this dataset) for its protein (i.e. found only in one protein / accession) */
	private Boolean isUnique;
	
	/** whether this PSM is a decoy, only set by some search engines */
	private Boolean isDecoy;
	
	/** caches the identification keys */
	private Map<String, String> identificationKeys;

	/**
	 * Basic constructor
	 */
	public PeptideSpectrumMatch(long id, int charge, double massToCharge,
			double deltaMass, Double rt, String sequence, int missed,
			String sourceID, String title, String spectraDataId,
			SpectrumIdentification spectrumID) {
		this.ID = id;
		this.sourceID = sourceID;
		this.spectraDataId = spectraDataId;
		this.isUnique = null;
		this.isDecoy = null;
		this.identificationKeys = new HashMap<String, String>(2);
	}


	/**
	 * Sets the pFile to the given file.
	 * 
	 * @param spectraDataId
	 */
	public void setFile(String spectraDataId) {
		spectraDataId = spectraDataId;
	}
	
	
	/**
	 * Getter for the ID.
	 * 
	 * @return
	 */
	public Long getID() {
		return ID;
	}

	/**
	 * Returns a String which explains the modifications in the Map.
	 * 
	 * @param modifications
	 * @return
	 */
	public static String getModificationString(
			Map<Integer, Modification> modifications) {
		StringBuffer modSb = new StringBuffer();
		boolean first = true;
		TreeMap<Integer, Modification> treeModMap =
				new TreeMap<Integer, Modification>(modifications);
		
		for (Map.Entry<Integer, Modification> modIt : treeModMap.entrySet()) {
			if (!first) {
				modSb.append('|');
			}
			modSb.append("[" + modIt.getKey() + ",");

			modSb.append("]");

			first = false;
		}
		
		return modSb.toString();
	}

	/**
	 * Getter for the sourceID.
	 * 
	 * @return
	 */
	public String getSourceID() {
		return sourceID;
	}
	

	/**
	 * This method returns a concatenation of the fileID and sourceID
	 * 
	 * @return
	 */
	public String getFileSourceID() {
		return spectraDataId + ";" +
				sourceID;
	}
	
	
	/**
	 * Getter for the file.
	 * 
	 * @return
	 */
	public String getFile() {
		return spectraDataId;
	}
	
	
	/**
	 * getter for isUnique.
	 * @return
	 */
	public Boolean getIsUnique() {
		return isUnique;
	}
	
	
	/**
	 * setter for isUnique.
	 * @return
	 */
	public void setIsUnique(Boolean unique) {
		this.isUnique = unique;
	}
	
	
	/**
	 * getter for isDecoy.
	 * @return
	 */
	public Boolean getIsDecoy() {
		return isDecoy;
	}
	
	
	/**
	 * setter for isDecoy.
	 * @return
	 */
	public void setIsDecoy(Boolean isDecoy) {
		this.isDecoy = isDecoy;
	}
	
	/**
	 * Returns a string to identify the spectrum. This is an identificationKey
	 * generated by {@link }
	 * using only the m/z, RT, sourceID, spectrumTitle and charge values, if
	 * they are given in the maximalKeySettings psmSetSettings. The sourceID and
	 * spectrumTitle would be sufficient, but are not always available.
	 * 
	 * @param maximalKeySettings
	 * @return
	 */
	public String getSpectrumIdentificationKey(Map<String, Boolean> maximalKeySettings) {
		Map<String, Boolean> psmSetSettings =
				new HashMap<String, Boolean>(maximalKeySettings);
		
		// remove the SEQUENCE and MODIFICATIONS, they are not needed for spectrumIdentificationKey
		psmSetSettings.remove(IdentificationKeySettings.SEQUENCE.name());
		psmSetSettings.remove(IdentificationKeySettings.MODIFICATIONS.name());
		
		return null;
	}
	
	
	/**
	 * Returns a string for identifying a PSM.<br/>
	 *This should be unique for each PSM and is used to pre-sort PSMs found by
	 * different searches. These have to be refined later, because valzues with 
	 * m/z-values can not be used, for identification, due to search engine
	 * roundings.
	 * 
	 * @return
	 */
	public static String getIdentificationKey(
			Map<String, Boolean> psmSetSettings, String sequence,
			String modificationString, int charge, Double massToCharge,
			Double rt, String sourceID, String spectrumTitle, Long fileID) {
		
		List<String> usedSettings = new ArrayList<String>();
		for (Map.Entry<String, Boolean> setSetting : psmSetSettings.entrySet()) {
			if (setSetting.getValue()) {
				usedSettings.add(setSetting.getKey());
			}
		}
		Collections.sort(usedSettings);
		
		StringBuffer key = new StringBuffer();
		for (String settingName : usedSettings) {
			String value = null;
			switch(IdentificationKeySettings.getByName(settingName)) {
			case CHARGE:
				value = Integer.toString(charge);
				break;
				
			case FILE_ID:
				value = Long.toString(fileID);
				break;
				
			case MASSTOCHARGE:
				if (massToCharge != null) {
					value = Double.toString(PIATools.round(massToCharge, 4));
				}
				break;
				
			case MODIFICATIONS:
				value = modificationString;
				break;
				
			case RETENTION_TIME:
				if (rt != null) {
					value = Double.toString((int)PIATools.round(rt, 0));
				}
				break;
				
			case SEQUENCE:
				value = sequence;
				break;
				
			case SOURCE_ID:
				value = sourceID;
				break;
				
			case SPECTRUM_TITLE:
				value = spectrumTitle;
				break;
			}
			
			if (value != null) {
				if (key.length() > 0) {
					key.append(":");
				}
				
				key.append(value);
			}
		}
		
		return key.toString();
	}
	
	
	/**
	 * Returns a string for identifying a PSM.<br/>
	 * This should be unique for each PSM and is used to pre-sort PSMs found by
	 * different searches. These have to be refined later, because values with
	 * m/z-values can not be used, for identification, due to search engine
	 * roundings.
	 * 
	 * @param psmSetSettings
	 * @return
	 */
	public String getIdentificationKey(Map<String, Boolean> psmSetSettings,
                                       String sequence,
                                       String modificationString,
                                       Double charge,
                                       Double massTocharge,
                                       Double rt
    ) {
		List<String> usedSettings = new ArrayList<String>();
		for (Map.Entry<String, Boolean> setSetting : psmSetSettings.entrySet()) {
			if (setSetting.getValue()) {
				usedSettings.add(setSetting.getKey());
			}
		}
		Collections.sort(usedSettings);
		
		StringBuffer keyKey = new StringBuffer();
		
		for (String key : usedSettings) {
			keyKey.append(key);
		}
		
		String key = identificationKeys.get(keyKey.toString());
		
		if (key == null) {
		/*	key = getIdentificationKey(
					psmSetSettings,
                    sequence,modificationString, charge, massTocharge, rt,
					this.getSourceID(),
					this.getFile().getID());
			identificationKeys.put(keyKey.toString(), key);*/
		}
		
		return key;
	}
	
	
	/**
	 * Returns a nice name / header for this PSM's spectrum
	 * @return
	 */
	public String getNiceSpectrumName(Double massToCharge, int charge, Double retentionTime) {
		StringBuffer spectrumName = new StringBuffer();
		
		if (sourceID != null) {
			spectrumName.append(sourceID);
		} else {
			spectrumName.append("[no sourceID]");
		}
		
		spectrumName.append(" (");
		spectrumName.append((int)PIATools.round(massToCharge, 4));
		spectrumName.append(", ");
		if (charge > 0) {
			spectrumName.append("+");
		}
		spectrumName.append(charge);

		if (retentionTime != null) {
			spectrumName.append(", ");
			spectrumName.append(PIATools.round(retentionTime, 0));
		}
		
		spectrumName.append(")");
		
		return spectrumName.toString();
	}

}